# web3層アーキテクチャ演習

# 初めに

これからweb3層アーキテクチャの各層の要素を理解するための実践演習を行う。

コンピュータシステムにおけるアーキテクチャとは、機能をどのように分割・配置するかについての方式のことである。3層アーキテクチャは、機能別に3層(レイヤ)に分割してハードウェア、ソフトウェア的な配置を行う。web3層とは3層アーキテクチャをwebシステムに適用したものである。

受講者が「？？？」な表情を浮かべていても無理はない。実体験も無く、実感も湧かないだろう。具体例を思い浮かべることもできない。頑張って知識として覚え込んだとしても、分離の理由や、各層の役割、**問題がどの層で発生しているかの調査方法**、等を問われると回答が難しいのではないか。

本研修は、受講者が実際に手を動かし、結果を目で見て、頭で意味を考える演習を通じて、具体的な事例を実体験し、実感を元に正しい理解ができるようになることを目的としている。

![](https://builder.japan.zdnet.com/storage/2016/03/18/2cad9de490394785bceac376f1e045bb/image8.png)

## 演習の方法

演習は、ターミナル（windowsではコマンド・プロンプト）と呼ばれる黒い画面で、キーボードからコマンドを入力し、その都度、結果を確認しつつ進める。
学習者はターミナル操作に慣れていないものと思われるため、基本的な操作（ディレクトリ移動、ファイル操作、ネットワーク操作、プロセス操作、等）については、都度確認のための操作演習を挟む。

![](https://eng-entrance.com/wp-content/uploads/2017/07/cui.png)

## 業務との関わり

web3層アーキテクチャについては、その前身の2層アーキテクチャ（クライアント・サーバシステム）と合わせ、我々が業務で担当するシステムの多くで採用され、日常的に向き合うことになる。本演習で得たアーキテクチャへの理解や、コマンドの基本的な操作は、日常業務の中で直接に役立つと思う。

# 演習の進め方

- 1層：　永続化層（データ層）
- 2層：　ビジネスロジック層（プログラム層）
- 3層：　プレゼンテーション層（ユーザーインターフェース層）

最初に単独でもシステムとして成立する1層のみで演習を行う。
次に、1層＋2層（クライアントサーバシステム）での演習を行い、最後に、1層＋2層＋3層（3層web）の演習を行う。

上の流れはコンピュータシステムの歴史の流れに沿っており、それぞれの時代の必要性に応じて
層の分割や追加が行われてきた。それらの理由や意味を確認するような演習を用意している。

# 1層：永続化層（データ層）

コンピュータシステムの大きな役割の一つは情報資源の蓄積である。
一方、プログラムやデータが保存されるメモリは、システムの停止や再起動で失われてしまう。
そのため、ディスク上のファイルやデータベースなどに永続的に情報を記録する。これが1層の永続化層（データ層）である。

一般にweb3層構造では、永続化層にはデータベースが使用されるが、単純なテキストファイルを使用することも可能である。

この後の演習では、同じテーマに対して、ファイル・データベース双方の操作を行い、その違いを実感してもらいたい。


## [題材]ニコニコカレンダー

ニコニコカレンダーとは、1日の出来事を振り返って感じた気持ち（いい感じ、まあまあ、やな感じなど。）をフェイスマークに書き表して、日々カレンダーに貼り付ける活動である。誰が、いつ、どのように感じたのか、それを全員で共有する必要がある。これを題材に永続化層の演習を進める。

![](https://www.consultsourcing.jp/cms/wp-content/uploads/2017/02/miss23image02.jpg)

データの保存（永続化）の対象先として、次の順番で演習を進める。
各段階で何らかの問題があり、順次見比べることで、(リレーショナル)データベースの役割や必要性を実感として理解してもらうことを意図している。

1. ローカルファイル
2. 共有ファイル(単体)
3. 共有ファイル(分散)
3. データベース

## コマンドプロンプトの起動

スタートメニューから「コマンドプロンプト」を起動する。
背景が黒いウィンドウが現れ、プロンプトが表示される。
以降の説明で、この`C:\Users\sofiauser`は省略し、記載しない。

`
C:\Users\sofiauser>
`

## ローカルファイル

最初に、データの保存先としてローカルファイルを利用する。合わせてwindowsにおける基本的なファイル操作の演習を行う。

### ファイル一覧の確認

以下の囲みは、[d][i][r]のキーを順次押して、その後[enter]キーを押すことを表す。
現在のディレクトリ（カレントディレクトリ）にあるファイルやフォルダの一覧が表示される。先頭に`>`が無い行はシステムが出力する内容である。入力しないこと。

```
> dir

ドライブ x のボリュームラベルがありません。
ボリュームシリアル番号は 0000-9999 です

c:\Users\sofiauserのディレクトリ

2018/04/01 01:10 <DIR> .
2018/04/01 01:10 <DIR> ..
以下省略
```

### 作業ディレクトリの作成

以下のコマンドを入力する。`mkdir` はmake directoryの略で、新しいディレクトリを作成する。 今後[社員番号]と出てきたら、自分の社員番号（6桁の数字）を入力する。先頭のゼロを省略しないこと。社員番号が`042073`であれば、`mkdir 042073work`と入力する。

```
> mkdir [社員番号]work
```

> work042073としなかったのは何故だろうか。次の履歴による補完と合わせ考えてみること。

### 履歴よる補完

上矢印キーを2回押す。プロンプトには`> dir`が表示されているはずである。
ここで[enter]を押すと、入力することなく同じコマンドを入力できる。今回は3文字であったので有用性が分かりにくいが、長いコマンドを再投入する場合、ありがたい機能である。

作成した[社員番号]workフォルダが存在することを確認する。

### タブによる補完

cdコマンド(change directory)は、現在のディレクトリ（カレントディレクトリ）を変更する。

`cd [社員番号の先頭1文字]`と入力し、[tab]キーを押す。
すると、カレントディレクトリから先頭が一致するフォルダ名を探し、補完が行われる。
先頭が一致するファイルやフォルダが複数あった場合、再度[tab]キーを押すと別の候補による補完が行われる。

先ほど作成したフォルダが表示されたら[enter]キーを押す。
念のため、`dir`コマンドで空であることを確認。

```
> cd [社員番号の先頭1文字][tab][enter]
> dir

ドライブ x のボリュームラベルがありません。
ボリュームシリアル番号は 0000-9999 です

c:\Users\sofiauser\098765workのディレクトリ

2018/04/01 01:10 <DIR> .
2018/04/01 01:10 <DIR> ..
以下省略

```

### 標準出力

echoコマンドは、パラメータを標準出力に出力する。
標準出力とは、コマンドプロンプトに表示される文字列であり、今までのコマンドも結果を標準出力に出力していた。
これだけでは何も面白いことは無いが、次のリダイレクトと組み合わせるとファイルへの出力を行うことができる。

```
> echo 2018-07-01,[社員番号],happy

2018-07-01,[社員番号],happy
```

### リダイレクト

コマンドに続けて、`> [ファイル名]`と入力すると、結果をカレントディレクトリのファイルに保存することができる。実行してみよう。

```
> echo 2018-07-01,[社員番号],happy > data.csv
> dir

~省略~
2018/04/01 01:10 123 data.csv

```

先ほどまで空であったフォルダ内に、data.csvファイルが作成された。

### ファイル内の確認
typeコマンドはファイルの内容を標準出力に出力する。

```
> type data.csv

2018-07-01,[社員番号],happy
```

が表示される。
データの内容は、2018/7/1に[社員番号]が感じた気持ちが、嬉しい(happy)であったことを表している。
これ以外に、悲しい（sad）、腹立たしい（angry）を使用していこう。


### データの追加

引き続き、7/2のデータを追加しよう。

```
> echo 2018-07-02,[社員番号],sad > data.csv
> type data.csv

2018-07-02,[社員番号],sad
```

おっと、7/1のデータが消えてしまった。
リダイレクトには`>`と`>>`の二種類の記号があり、`>`はファイルの内容を消去してしまう。（厳密には、長さ情報をゼロにして、先頭か

ら書き込みを行う）
最終行に追記するには、`>>`を利用する。

### ヒストリ機能

消してしまった7/1を再登録するため、ヒストリ機能を利用しよう。
[↑]を4回押して7/1の情報登録コマンドを呼び出そう。

> [F7]キーを押すと、選択用のリストボックスが表示される。[↑][↓]キーで実施したい履歴を選び、[enter]で実行できる。
> 修正を伴わないのであれば、この方法も利用できる。

```
> echo 2018-07-01,[社員番号],happy > data.csv
```

このまま実行すると、また7/2の情報を消してしまうが、呼び出したヒストリのコマンドは修正することができる。
[←]キーでカーソルを`>`の直後まで移動させ、[>]キーを押して、>を>>に変更する。

```
> echo 2018-07-01,[社員番号],happy >> data.csv

> type data.csv
2018-07-02,[社員番号],sad
2018-07-01,[社員番号],happy
```

7/2のデータを消すことなく7/1のデータを追加できた。
更に何日分かデータを追加してみよう。

```
> type data.csv
2018-07-02,[社員番号],sad
2018-07-01,[社員番号],happy
2018-07-04,[社員番号],bad
2018-07-03,[社員番号],angry
```

sadをbadと打ち間違えてしまった。後ほど更新しよう。


### 並べかえ

typeで出力すると、データの追加順に表示される。日付順に表示するにはどうしたらよいだろうか。`sort`コマンドを利用してみよう。

```
> sort data.csv

2018-07-01,[社員番号],happy
2018-07-02,[社員番号],sad
2018-07-03,[社員番号],angry
2018-07-04,[社員番号],bad
```

日付順にデータが表示された。

sortコマンドには色々なオプションがある。`sort /?`とするとヘルプと呼ばれる簡易的なマニュアルが確認できる。

以下のコマンドを試してみよう。
登録した「気持ち」のアルファベット順での並べ替えである。各行の19文字目以降で並べ替えを行っている。

```
> sort /+19 data.csv

2018-07-03,[社員番号],angry
2018-07-04,[社員番号],bad
2018-07-01,[社員番号],happy
2018-07-02,[社員番号],sad
```

### データの選択と表示

7/4の情報のみ表示したいときはどうしたらよいか。
いくつか方法がある。

#### findコマンド

```
> find "07-04" data.csv
------------ data.csv
2018-07-04,[社員番号],bad
```

#### パイプ＋findstrコマンド

```
> type data.csv | findstr 07-04
2018-07-04,[社員番号],bad
```

縦棒「|」はパイプ記号と呼ばれ、標準出力をファイルではなく次のコマンドに渡す。キーボードの右上、「￥」と同じキーに割当てられている

。シフトキー＋「￥」で入力しよう。findstrは一致する行を出力する。`findstr /?`でその他の使い方を確認してみよう。


### データの更新

7/4のbadは、sadの打ち間違いであった。修正してみよう。
コマンドプロンプトはwindows3.1からある古いプログラムであり、機能が無い。windows7以降に標準で搭載されているPowershellを使おう。次のコマンドでPowershellを起動する。

```
> powershell
Windows Powershell
Copyright (C) 2009 Microsoft Corporation. All rights reserved.

PS C:\Users\sofiauser\[社員番号]work>
```

コマンドプロンプト先頭のPSが、現在Powershellを実行中であることを示している。また、ウィンドウタイトルを見てみると、コマンドプロンプト- powershellとなっている。

### Powershellのコマンド

今まで利用してきたコマンドを入力してみよう

```
> dir
 ディレクトリ: C\Users\sofiauser\[社員番号]work

Mode  LastWriteTime   Length Name
----  -------------   ------ ----
-a--- 2018/07/01 9:00    150 data.csv

> type data.csv
2018-07-02,[社員番号],sad
2018-07-01,[社員番号],happy
2018-07-04,[社員番号],bad
2018-07-03,[社員番号],angry

> sort data.csv
```

### Powershellのヘルプ

dir,typeは同じように動作するが、sortは何も出力されない。
/?で調べてみよう。

```
> sort /?
```

何も表示されない。
powershellでは/?に代わって`get-help`コマンドが用意されている。

```
> get-help sort

名前
    Sort-Object
    
概要
    プロパティ値に基づいてオブジェクトを並べ替えます。
    
    
構文
    Sort-Object [[-Property] <Object[]>] [-CaseSensitive] [-Culture <string>] [-Desce
    nding] [-InputObject <psobject>] [-Unique] [<CommonParameters>]

[以下省略]
```

説明が出てきた。名前を見ると`Sort-Object`となっている。これはどういうことだろうか。次のコマンドを入力して確認してみよう。

```
> get-command sort

CommandType     Name                               Definition                        
-----------     ----                               ----------                        
Alias           sort                               Sort-Object                       
Application     sort.exe                           C:\Windows\system32\sort.exe   
```

Aliasとは別名のことである。長い名前を都度入力するのではなく、短縮した省略形で入力したい場合などに利用する。sortの実態はPowershellのコマンドSort-Objectであったのだ。

```
> type data.csv | sort
2018-07-01,[社員番号],happy
2018-07-02,[社員番号],sad
2018-07-03,[社員番号],angry
2018-07-04,[社員番号],bad
```

### 更新処理(Update)

少し遠回りをしたが、7/4のbadをsadに変更しよう。

```
> copy data.csv tmp
> dir

Mode  LastWriteTime   Length Name
----  -------------   ------ ----
-a--- 2018/07/01 9:00    150 data.csv
-a--- 2018/07/01 9:00    150 tmp

> type tmp | %{$_ -replace 'bad','sad'} > data.csv
> type data.csv
2018-07-02,[社員番号],sad
2018-07-01,[社員番号],happy
2018-07-04,[社員番号],sad
2018-07-03,[社員番号],angry
```

作業前にdata.csvを別ファイルにコピーしている。自分から読んで自分に書き込めるのか、以下のコマンドを試してみよう。

```
> type data.csv | %{$_ -replace 'bad','sad'} > data.csv
> type data.csv
```

内容が消えてしまった。リダイレクトによる書き込みは最初にファイルのサイズをゼロに変更するのであった。そのため、読み込み処理が即時に中断し、空ファイルが残った。以下のコマンドで復旧させよう。

```
> type tmp | %{$_ -replace 'bad','sad'} > data.csv
```

### 条件を指定して更新

よく考えてみると、7/2はhappyであった。修正したい。
先ほどと同じコマンドを使用すると7/4も変更してしまうが、Powershellは正規表現というものが使用できるので、以下のように7/2のみ変更することができる。
```
> copy data.csv tmp
> type tmp | %{$_ -replace 'bad','sad'} > data.csv
> type data.csv
2018-07-02,[社員番号],happy
[省略]
```

### 条件を指定して削除

7/1のデータを削除することになった。どのようにしたら良いだろうか。
方法は色々あるが、以下のコマンドで実行してみよう。

```
> copy data.csv tmp
> type tmp | ?{-not ($_ -like '*07-01*')} > data.csv
> type data.csv
2018-07-02,[社員番号],happy
2018-07-04,[社員番号],sad
2018-07-03,[社員番号],angry
```

### Powershellの記号

さて、特に説明をしなかったが、記号%や、?は何を意味しているのだろうか。

```
> get-command %

CommandType     Name                               Definition                        
-----------     ----                               ----------                        
Alias           %                                  ForEach-Object    
```

`%`はForEach-Objectの省略形であった。

```
> get-help foreach-object
[省略]
```

get-helpで簡易マニュアルを確認することができる。
便利で他機能なPowershellは、日常業務の中で活用することも多い。
これ以上の詳細説明は本演習の範囲を越えるため言及しないが、調べてみるの面白いだろう。

余談であるが、先頭がアルファベット以外であるコマンドの一覧は、以下のようにして求められる。
```
> get-command | ?{$_.Name -match '^[^a-zA-Z]'}
```

### CRUD

これでデータの操作のうち、作成(CREATE)、表示(READ)、更新(UPDATE)、削除(DELETE)を行うことができた。この四種類でデータの操作を網羅していると言って良い。頭文字をつなげて、CRUD（クラッド）または、CRUD操作と呼ぶ。

## 共有ファイル

さて、現時点でも個人専用のニコニコカレンダーとして機能しないこともない。
ただし、大きな機能が欠落している、データの共用である。

- 7/1にhappyだった人は何人いるのか
- 月を通してsadが一番多かった人はだれか

このような人を横断した処理は、今の各自がローカルファイルにデータを保存している状態では行えない。
最終的には、データベースと呼ばれる永続化層を利用するが、その前に共有ファイルで実現できないか試してみよう。

### ネットワーク

若干ネットワーク関連の寄り道をする。
共有ファイルは、演習で使用しているパソコンのハードディスクではなく、サーバと呼ばれるコンピュータのハードディスク上にある。講師の手元

にある四角い箱がそれである。このサーバに若干30名が**ネットワーク**経由で接続する。

### ローカルディスク

ローカルファイルとのデータのやり取りの場合、パソコンの中にある基盤（マザーボード）とハードディスクを結ぶ電線（ケーブル）を通して、データを電気信号として送信していた。電気信号を受け取ったハードディスクは、回転する磁性体の上で電磁石を動かし、磁気的に情報を記録していた。

ハードディスクを複数搭載したパソコンの場合、c:, d:など、ドライブレターと呼ばれるアルファベットの頭文字をディスクに割り当てる。 
以下のコマンドを試してみよう。

```
> get-command c:
```

コンソール上で、ドライブレター:を入力すると、作業場所が切り替わった。Powershellにおいては、`Set-Location`コマンドにドライブ名をパラメータとして渡しているのである。
つまり、Windowsでは別々の区画として接続できるハードディスクの最大数は、A-Zの26個である。

### IPアドレス

共有ファイルにおいて、電線（ケーブル）の役割を行うのは、LANケーブルや、電波（Wifi）である。
現在この教室には30人弱のパソコンがあり、ネットワークに接続されている。それぞれの端末をどのように区別しているのだろうか。何がドライブレターに相当するのだろうか、もし、26種類が上限であれば、教室の全員に割当てることができない。

現在、ほとんどのネットワークで利用されているTCP/IPプロトコルでは、各パソコンやネットワーク機器（ルータ等）に**IPアドレス**と呼ばれる値を割り当てる。同じIPアドレスは一つの機器にしか割当ててはいけない。もし重複して登録すると後から接続した機器でエラーが発生する。場合によっては、最初から接続していた機器宛のデータを受信してしまうかもしれない。

以下のコマンドで自分が今利用しているパソコンのIPアドレスを確認してみよう。

```
> ipconfig

Windows IP 構成


Wireless LAN adapter ワイヤレス ネットワーク接続 2:

   接続固有の DNS サフィックス . . . : 
   IPv4 アドレス . . . . . . . . . . : 192.168.1.2
   サブネット マスク . . . . . . . . : 255.255.255.0
   デフォルト ゲートウェイ . . . . . : 192.168.1.1

イーサネット アダプター ローカル エリア接続:

   メディアの状態. . . . . . . . . . : メディアは接続されていません
   接続固有の DNS サフィックス . . . : 
```

IPv4アドレスの後ろに表示された文字列`192.168.1.2`が、自分が今利用しているパソコンのIPアドレスである。
数字が4つピリオドで区切って並べてある。内部的には32bitの2進数であり、可読性の為に8ビットずつ数字にしてある。

IPアドレスを付与したコンピュータがネットワークに接続されており、到達可能であれば、以下の`ping`コマンドで応答が確認できる。
[IPアドレス]とある箇所は、隣の人からIPアドレスを教えてもらおう。


```
> ping [IPアドレス]
```


### サブネットマスク

さて、更に周囲の人からIPアドレスを聞いてみよう。並べてみると法則性に気が付くと思う。
区切られた数字の、先頭3つが、全員一致しているはずだ。

これは、サブネットマスクの設定と関係する。

先ほど確認した時、サブネットマスクは255.255.255.0であった。
255は2進数で標記すると特殊な数字である。以下のコマンドで確認してみよう。

```
> [Convert]::ToString(1,2)
1
> [Convert]::ToString(2,2)
10
> [Convert]::ToString(3,2)
11
> [Convert]::ToString(4,2)
100
> [Convert]::ToString(255,2)
11111111
```

先ほど、IPアドレスは内部的に2進数の数字だと言った。つまり、このサブネットマスクは2進数で標記すると以下のようになる。
見やすさのために8桁ごとに空白を入れてある。

`11111111 11111111 11111111 00000000`

### ビット演算

基本情報処理試験で勉強したビット演算を覚えているだろうか。
Powershellでは、`-bor`で論理和、`-band`で論理積が計算できる。試してみよう。

```
> [Convert]::ToInt32("000011111111",2)
255

> [Convert]::ToInt32("111111110000",2)
4080

> [Convert]::ToString(255 -band 4080, 2)
11110000
```

2つの2進数について、1が重なったところが残る（マスクされる）ように見えないだろうか。
同じように、`255.255.255.0`と論理積を取ると、先頭の3つの数字を残し、4つ目はゼロになる。

残った３つの数字をサブネットアドレスと呼び、イーサネットと呼ばれる接続方式であれば、MACアドレスを利用した直接通信ができる。


### MACアドレス

手元のコンピュータには、LANケーブルが接続されているだろうか。ケーブル内には電線があり、電気的に回路に接続されている。の電子回路は現在は一つのICチップに機能が集約されているが、古くは基盤（拡張カード）上に多数の部品を載せて構成していた。

その名残で、ネットワークインターフェースカード（NIC、ニック）と呼ぶ。

長くなったが、MACアドレスはNICに割り振られた48bitの数字である。
一つ一つ別の数字が割り当てられ、重複すると不具合を引き起こす。

見やすさのために、16進数2ケタの6つ組で表示されることが多い。
自分のパソコンのMACアドレスを確認してみよう。


```
> ipconfig /all
[省略]
   物理アドレス. . . . . . . . . . . : A4-5D-36-17-75-10
[省略]
```

物理アドレスとあるものが、自分のパソコンのMACアドレスである。
pingと同じようにMACアドレスを指定して応答を確認するコマンドは、残念ながら標準的には存在しない。

自分以外のパソコンのMACアドレスはどう調べるのだろうか。
以下のコマンドを実行してみよう。


```
> arp -a

インターフェイス: 192.168.20.249 --- 0x10
  インターネット アドレス      物理アドレス      種類
  192.168.20.1          00-60-b9-e8-87-e2     動的        
  192.168.20.50         50-65-f3-f1-94-cc     動的        
  192.168.20.53         7c-5c-f8-ef-f4-61     動的        
  192.168.20.54         b4-b6-76-a1-b6-16     動的        
  192.168.20.55         7c-5c-f8-f8-cd-f2     動的    
[省略]

```

先ほどpingで確認したIPアドレスに対応したMACアドレス（物理アドレス）が表示された。
MACアドレスを使用した通信は、かなり乱暴である。同じハブに繋がっているコンピュータ全てに、MACアドレス付でデータを送信する。
受信者は、自分のMACアドレス宛でなければ、都度データを破棄する。このデータをパケットと呼ぶ。

Wiresharkというツールを起動してパケットの様子を見てみよう。
操作方法は別添のマニュアルを参照すること。

何も操作をしなくても、大量のパケットが飛び交っていることが見えたと思う。
だいたい一つのサブネット配下には、100台～200台程度の機器を所属させる。
機器がそれを大きく超えて増えると、パケットを破棄するだけの処理で処理能力が食いつぶされてしまう。

### デフォルトゲートウェイ

サブネットが同じであれば、MACアドレスによる直接通信を行うと知った。では、サブネットが異なる場合はどうするのだろうか。
その場合は、デフォルトゲートウェイとして設定した機器に、その先の通信を任せる。

ゲートウェイは、複数のMACアドレスを持ち、複数のサブネットに所属していることが普通である。
また、更に上位のデフォルトゲートウェイを持つ。

受け取ったパケットが自分のサブネットのどれかに所属する場合、MACアドレスによる通信を行い、パケットを宛先コンピュータに届ける。
自分のどのサブネットにも所属していない場合、自分のゲートウェイに転送し、その先を処理を任せる。

`tracert`コマンドは、パケットが経由するゲートウェイを調べて表示する。

```
> tracert [IPアドレス]
```

### 共有フォルダ

ネットワークへの寄り道はいったん終了である。
引き続き共有フォルダに接続して、一つのファイルを共有しての永続化層の演習に戻る。

以下のコマンドにより、サーバ上の共有フォルダを、Z:ドライブとして利用できるようにする。（マウントする）

```
> net use z: \\[サーバのIPアドレス]\[共有名] /user [ユーザー名] [パスワード]
```

各種パラメータは、当日の環境により異なる。講師から伝達されるのでそれを利用すること。

```
> z:
> cd share
> pwd

Path
----
Z:\
```

pwdコマンドは、process working directoryの略で、Get-Locationの略称である。現在のディレクトリを表示する。
Z:ドライブの実体はサーバ上のハードディスクであり、現在全員が同じ場所を参照している。


### ファイルの作成

それではローカルファイルで行ったデータ操作を順に行ってみよう。

```
> echo 2018-07-01,[社員番号],happy > data.csv
> type data.csv
```

全員で同じファイルに対して書き込みを行った。
タイミングが悪いとエラーが出た人もいたのではないかと思う。

出力される内容は、誰か一人分になるはずである。


### ファイルの作成（個人別）

まずは個人別にファイル名を分けてみよう。

```
> echo 2018-07-01,[社員番号],happy > [社員番号]data.csv
> type [社員番号]data.csv
2018-07-01
[社員番号]
happy
```

カンマで区切った項目が別の行に分かれてしまった。
そういえば現在、Powershellを起動していたのであった。Powershellでは、カンマは文字列自体ではなく、引数の区切り文字と見なされる。
echoコマンドに3つの別々のパラメータを渡したとみなされたのである。カンマも含め文字列とするには、全体を""で囲む。

```
> echo "2018-07-01,[社員番号],happy" > [社員番号]data.csv
> type [社員番号]data.csv
2018-07-01,[社員番号],happy
```

意図した通り登録された。


### ファイルの作成（共通）

実は、`>>`はファイルが存在しない場合新たにファイルを作成する。
全員で以下の操作を実施した場合、全データが一つのファイルに書き込まれるはずである。試してみよう。

```
> echo 2018-07-01,[社員番号],happy >> data.csv
> type data.csv
[省略]
```

タイミングによるが、`type`で表示されるデータに自分以外のものが含まれているはずである。


### 件数の集計

エラーなく全員のデータが集まっただろうか。受講者の人数を講師から聞き、行数が一致することを確認しよう。

```
> type data.csv | measure-object


Count    : 30
[省略]
```

Countのところに、行数が表示される。人数と一致しているだろうか。


### 条件を指定しての表示

今こっそりと講師が1人分のデータを削除した。
誰のデータが削除されたのだろうか、自分の社員番号を含む行を表示させて、何も表示されない人は手をあげること。

テキストを遡って、やり方を見つけること。
日付を指定した行表示の例を少し修正するとできるはずである。


### 再登録

手を挙げた人は、Luckeyをデータ値として再登録すること。1/30の確率である。あなたは運が良い。
また、社員番号を皆に告げること。他の人はその番号で検索する。または、Luckeyで検索しても良い。


### データの追加

同じように、7/2～7/4のデータを追加してみよう。
`>>`によるファイル末尾へのデータ追加は、このくらいの人数であればエラーにならない。
（はずである。事前に10,000ユーザーで検証してみた）


### データの更新

ローカルファイルの時と同じ方法で、7/4の気持ちを変更してみよう。

実施しただろうか。
結果を見ると分かると思うが、更新されていない人がいるはずである。手をあげて欲しい。
Aさん、Bさんが同時に編集をして、以下のような順番になった場合、Aさんの更新は元に戻ってしまう。（デグレード）

`Aコピー　-> Bコピー -> A上書き -> B上書き`


### ロック（排他制御）

デグレードを防ぐための方法の一つがロックである。
ロックを保持していないと`copy data.csv tmp`をしてはいけないルールとする。また、データの上書きをした後にロックを戻す。

`Aロック取得 -> Aコピー　-> A上書き -> Aロック戻す`

講師が今、トランプのジョーカーを持っている。これを先ほどの運が良い受講者に渡す。
このトランプのジョーカーが、今この教室でのロックである。

ロックを持っている受講者は、作業が終わったら手にジョーカーを持って「欲しい人」と言う。
次に作業がしたい人は、手をあげて「欲しい」と言う。
誰か選んでトランプのジョーカーを渡そう。

これを全員分繰り返すと、すごい時間が掛ってしまう。
三人ほど繰り返したら終了しよう。


### 大量検索

共有フォルダ配下に`10m.csv`という名前のファイルがあることに気付いただろうか。
このファイルにはニコニコカレンダーのデータが一千万件記録されている。

この中からweird（奇妙な）気持ちのデータを探してみよう。

```
> type 10m.csv | findstr weird
```

やり方は今までの方法と何ら変わらないが、5秒～10秒掛ったのではないか。

ファイルから情報を探す場合、先頭から一件ずつ探すしかない。
この方法は線形探索と呼ばれ、平均すれば件数の半分（今回の場合五百万回）の比較が必要になる。

一回0.001㍉秒(=1マイクロ秒)であったとしても、5秒かかる計算である。
ファイルに保存したデータは、一括処理には向いていても、無作為な取り出し（ランダムアクセス）には向いていない。


### 共有ファイル方式の限界

CRUDの4機能について、共有ファイルを使った方式では以下の制約があることが分かった。

|方式|英語表記|制約|特徴|
|:---|:---|:---|:---|
|追加|CREATE|制約なし||
|読み出し|READ|線形検索のみ|件数が多くなると遅い|
|更新|UPDATE|ロック（排他制御）が必要|遅い|
|削除|DELETE|ロック（排他制御）が必要|遅い|

**データベース**を利用すると、線形検索より高速なインデックス検索の機能が利用できる。
また、効率的かつ高速にロック（排他制御）を実現する機能が提供される。


## データベース

それではいよいよ、データベースを利用した演習を進めていこう。

### Teraterm

Teratermを使用してlinuxサーバへ接続する。接続方法は別途配布資料を参照のこと。
linuxで動作する`psql`というターミナルプログラムを利用するため、このような方法を取る。

接続が終了すると、いままでと同様にコマンドプロンプトが表示される。
`psql`コマンドを投入してデータベースに接続する。

```
> psql -h [ホスト名] -U [ユーザー名]
```

### テーブル一覧

今、calenderという名前のデータベースに接続している。
ファイルに相当するデータの入れ物がテーブルである。

以下のコマンドでテーブル一覧が確認できる。
ファイル一覧の`dir`に相当する。

```
> \l
m10
```

`m10`という名前のテーブルが一つだけ存在している。これは後程演習に使用するサンプルテーブルで、データが**1000万レコード**登録済である。

### テーブル作成

それでは、ニコニコカレンダー情報を登録する`smile`テーブルを作成する。
作成するテーブルの定義情報は以下の通り。

|項目名|フィールド名|型|制約|
|:---|:---|:---|:---|
|日付|edate|date|not null|
|社員番号|number|integer|not null|
|気持ち|emotion|char(16)|not null|

- 主キー（日付、社員番号）


詳細な説明に入る前に、まず演習してみよう。

```
> create table smile (edate date not null, number integer not null, emotion char(16) , primary key (edate,number));
CREATE TABLE
or
ERROR: relation "smile" already exists
```

全員で同じテーブルを一斉に作成した。どのような結果になっただろうか。
最初の1名を除きエラーになったはずである。

ファイルの時は上書きしてしまったが、テーブルについては削除`drop`した後でなければ同じ名前のテーブルを作成できない。


### レコードの登録と参照

最初の情報を登録してみよう。

```
> insert into smile values ('2018-07-01', [社員番号], 'happy');
INSERT 0 1
> select * from smile;
> select * from smile where number = [社員番号];
  edata    | number    | emotion
-----------+-----------+-------
2018-07-01 | [社員番号] | happy
(1 row)
```

最初の`select`では全データが表示され、`where`を追加すると自分のデータのみが表示されている。
`where`を利用すると、条件を指定して特定のレコードを取り出すことができる。

### 重複防止(ユニーク制約)

テキストの前の方の、実際の紙のニコニコカレンダーの画像を見てみよう。
空の日付のマスに表情のシールを貼っている。既にシールが張っている場所への

同じ社員の同じ日付のマスに別のシールを貼ろうとすると、下のシールを消してしまう。


同じ名前のテーブルを`create`した時と同じように、このような登録も重複エラーになる。試してみよう。

```
> insert into smile values ('2018-07-01', [社員番号], 'sad');
ERROR: duplicate key value violates unique constraint "smile_pkey"
DETAIL: key (edate, number)=(2018-07-01, 42073) already exists.
```

カレンダーのマスは、社員と日付と1対1に対応している。先ほどテーブル作成時に`primary key (edate,number)`と設定したことがそれに該当する。
同じマスに複数のレコードを登録できないような制約(constraint)が発生し、制約エラーになる。

> primary keyを**主キー**、特に複数のフィールドからなるものを**複合主キー**と呼ぶ。
> また、日付も社員番号も、利用者からみて意味のある情報である。これを**自然キー**と呼ぶ場合がある。
> もし、レコードごとに異なる値をシステム的に設定(例えば、'AE-0F-33-76'など)した場合、**サロゲートキー**と呼ぶ。

> ある実態と1対1に対応することをユニーク(unique)である、一意であるなどと言い、これは実態に対するキー、またはキー情報である。
> IPアドレスやMACアドレスは、NICに対するキー情報の条件を満たし、候補キーと呼ぶ。候補キーの中から選ばれた一つが主キーとなる。

### 空白マス(NULL)

空白のマスだけ予め作っておくことになったとしよう。
7月2日の空白マスは以下のように作成する。

```
> \pset null [null]
Null display is "[null]"

> insert into smile (edate, number) values ('2018-07-02', [社員番号]);
INSERT 0 1
> select * from smile where number = [社員番号];
  edata    | number  | emotion
-----------+---------+-------
2018-07-01 |[社員番号]| happy
2018-07-01 |[社員番号]| [null]
```

`emotion`フィールドをセットしていない、指定していないフィールドの値は、デフォルト値を設定していない限り、**NULL**になる。デフォルトの設定では、null値は単に空白文字として表示されるので`\pset null`コマンドで明示的に表示している。

プログラミング研修において、javaのnull値を学んだと思う。概念は同じであり「定義されていないこと」を示す。

では、空白マスだけを表示するにはどうしたら良いだろうか。
以下のコマンドを実行してみる。

```
> select * from smile where emotion = NULL
  edata    | number  | emotion
-----------+---------+-------
(0 rows)
```

期待に反して該当行なし(0 rows)になる。
nullの判定には専用の構文が用意されており、それを使用しなくてはならない。

```
> select * from smile where emotion is null
  edata    | number  | emotion
-----------+---------+-------
2018-07-01 |[社員番号]| happy
2018-07-01 |[社員番号]| [null]
(1 row)
```

空白でないマスは以下の書き方になる。

```
> select * from smile where emotion is not null
```

> 余談：困ったことにoracleでは文字列が""の時にもis nullが成立する

### 必須入力防止(not null 制約)

入力が必須であり、



# 検索アルゴリズム演習

データベースの利点は、ロック制御と、高速な検索であると述べた。
実際、1000万件のファイルを順番に（線形に）検索したところ、とても時間がかかったと思う。

データベースを導入すると大量データを高速に検索してくれるが、内部のことを全く理解しなくて良いわけではない。
昨日まで順調に動作していたデータベースが、ある日からとても遅くなることがある。原因を調査して対策を実施し、予防策を講じるのは我々である。

こう行った問題に対処するためには、検索方法の種類や計算回数の違いに踏み込んだ理解が必要だが、目に見えないため実感が湧きにくい。
これから代表的な検索方法について、ゲーム形式で手を動かして演習してもらう。具体例として実感してもらい、踏み込んだ理解の助けにしてもらいたい。

一旦データベースの接続を解除する。`\q`コマンドを利用する。

```
> \q
```


## 線形検索

君たちは海賊だ。島を巡ってお宝を探している。
さて、以下のコマンドを入力してみよう。

```
> cd liner_sea
> ls
island00 island01 ... island99
```

線形海[linersea]に出航し、島[island]を20個発見した。島には01から20までの連番の数字が付与されている。
最初の島に上陸してみよう。

```
> cd island01
> ls -la
> cat box.txt
null
````

箱[box]があり`null`と書いてあった。何も入っていない。ハズレである。`map`と書いてあれば宝の地図である。宝の地図を探してみよう。ただし、`cat`と、`cd`コマンド以外は使用できないものとする。

> `cd ..`とすると、一つ上のディレクトリに移動できる。

### 解説

何回で発見できただろうか。地図が一枚しかなければ、平均回数は10回になる。一回3秒で探したとして、30秒である。線形検索のことをフルスキャンと呼ぶことがある。

## 二分検索

さて、宝の地図を見ながら、次の海に乗り出そう。

```
> cd ..
> cd binary_sea
> ls
```

今度は1000から9190まで8191個の島がある。
フルスキャンでは3時間30分かかる計算だ。

だが今回はヒントがある。
箱の中身は6桁の数字で、小さい方から島の番号順に並んでいる。また、数字の重複は無い。

`777777`がお宝である。それ以外の数字は毒矢である。

毒矢を10回受けると海賊は死ぬ。
さて、毒で死んでしまう前にお宝を見つけられるだろうか。試してみよう。

### 解説

端から順番に調べた人はいなかったと思う。
だいたい真ん中から調べて、宝がある方をまた半分にして絞り込んだのではないか。

> 数字が均一に並んでいると仮定して線形補完を試みた人は冴えている

範囲を半分ずつに減らしながら検索する方法を二分検索と呼ぶ。
ソート済のデータの検索として有利な方法である。

1回の検索で決定できるデータの数は3である。
2回であれば７、3回なら15、
以後、31,63,127,255,511,1023,2047,4095,8191となることから、
12回検索すれば必ず発見できることが分かる。

> n回の検索では、n-1回の時の2倍＋１回のデータ数を決定できる
> これは漸化式である

9回目の選択では最悪でも15択である。
受講者は30人いる。一人ぐらいは生きて宝を得られるのではないか。

### 余談：Wolfram Alpha

方程式のような数式の処理をコンピュータで行うためのシステムにMathematicaがある。
それをwebで使えるようにしたものが、Wolfram Alphaである。

[WolframAlpa https://www.wolframalpha.com/](https://www.wolframalpha.com/)

先ほどの漸化式であるが、理系の学生であれば手計算で一般項が算出できるだろう。手計算しなくても、WolframAlphaに解いてもらうことができる。一般項が分かれば、プログラムに落とし込める。
以下の通り入力してみよう。

```
> x(1)=3;x(n)=2x(n-1)+1
x(n) = 2^(n+1)-1 
```

12回の検索で決定できる数は、2の13乗マイナス1である。
2の10乗は1024(これは覚えておくと便利)であるので、
1024->2048->4096->8192が2の13乗であり、確かに一致する。

プログラムでは以下のように書ける。(javaの例)

```java
Math.pow(2,n+1)-1
```


このサイトはぜひ覚えておいてほしい。
さすがに漸化式の計算を頻繁にさせるとは思わないが、
以下のような計算がしたくなることは業務上頻繁にある。

「5テラバイトのファイルをUSB2.0経由で転送するとどのぐらいの時間がかかるか」

WolframAlfaは以下のように入力すると計算できる。

```
> 5TB / USB2.0
23.15hours
```

23.15時間かかるそうだ。
別のもっと早い方法を考えたほうが良い。

では、3時間で転送するために必要な転送速度はどのぐらいか。
以下のように計算できる。

```
> 5TB / 3hour as bps
3.7Gbps
```

`USB3.0`が`5Gbps`なので試してみよう。

```
> 5TB / USB3.0
2hours 13minutes
```

2時間13分で転送できそうだ。

# ハッシュ検索

さて、次の航海に出航しよう。

```
> cd ..
> cd hash_sea
> ls -la
island_aabe
island_12fe
```

今度は7721個の島に、8191個の宝箱が隠されている。島の数は本当に8191個あるだろうか、確認してみよう。

```
> ls | wc -w
7721
```

どうやら間違いなさそうだ。
`wc`コマンドは`word count`の略で、行数、単語数、文字数などを数えあげる。`-w`オプションは、単語数を教えてくれる。詳細は`wc --help`で確認。

さて、今回の海も、`island`フォルダの中に、`box[番号].txt`というファイルがあり、ファイルには数字が記載されている。`777777`が宝物である。

島には複数の宝箱がある場合があり、番号が`01`,`02`と増える。箱の番号順に、中身の番号はソート済である。

`777777`以外の数字は猛毒である。2回で海賊は死亡する。

さてどうするか。
ヒントはハッシュ関数にある。

今度は`cat`,`cd`に加えて、`md5sum`,`cut`を宝探しに使って良い。
この`md5sum`がハッシュ関数を利用して、ハッシュ値を求めるコマンドである。

## ハッシュ関数

ハッシュ関数とはなんだろうか。
色々試してみよう。

```
> echo -n 1 | md5sum
> echo -n 1 | md5sum
> echo -n 12 | md5sum
> echo -n 12 | md5sum
> echo -n 123 | md5sum
> echo -n 1234 | md5sum
> echo -n 12345 | md5sum
> echo -n 123456 | md5sum
> echo -n 123457 | md5sum
> echo -n 123458 | md5sum
> echo -n abc | md5sum
> echo -n abc | sha1sum
> echo -n abc | sha256sum
```

> echoは`-n`オプションを付けると改行文字を含めない

MD5,SHA1,SHA256がハッシュ関数の種類である。
出力されたものを見ると、以下のような傾向が見て取れる。

- 入力が同じであれば、出力される文字列も同じである
- 入力の長さが何であっても、出力される文字列の長さは関数の種類別に固定である
- 入力文字の一部が変わっただけでも、出力される文字列が大きく変わる
- MD5よりSHA1、SHA1よりSHA256の方が、出力される文字列の長さが長い


## ハッシュ衝突

それでは、同じハッシュ値を持つ異なる文字列はあるのだろうか。
以下を試してみよう。

```
> cd collision
> md5sum *.exe
cdc47d670159eef60916ca03a9d4a007 *erase.exe
cdc47d670159eef60916ca03a9d4a007 *hello.exe

> sha1sum file*
> sha256sum file*
> cd ..
```

異なる二つのファイルから同一のMD5ハッシュ値が出力された。これをハッシュ値の衝突と呼んでいる。
SHA1は長らく衝突が報告されていなかったが、2017年にGoogleから実例の報告があった。

念のため、本当に中身が異なっていることを確認しよう。

```
> diff -u <(hexdump hello.exe) <(hexdump erase.exe)
--- /dev/fd/63  2018-04-15 10:39:27.709473226 +0000
+++ /dev/fd/62  2018-04-15 10:39:27.709473226 +0000
@@ -115,13 +115,13 @@
-0000750 0535 e127 00c0 f3e1 13d8 552c 49be 3e54
+0000750 0535 6127 00c0 f3e1 13d8 552c 49be 3e54     
```

115行の13文字目が異なっている。

ハッシュ関数はデジタル証明書にも使用されており、意図して同じハッシュ値を持つファイルを作成できない性質を利用して、改ざんや偽造防止の根拠としていた。故意に衝突を起こせるなら、改ざんや偽造が可能になるため、ハッシュ関数の脆弱性と呼ばれる。

SHA256の衝突は未だ報告されていない。

## ハッシュ検索

今回のヒントはハッシュ関数であると言った。
MD5関数で箱の中身のハッシュ値を計算する。その先頭4文字が島の番号になっている。

早速求めてみよう。

```
> echo -n 777777 | md5sum | cut -c -4
f63f
```

宝は`island_f63f`にあることが分かった。
早速島に上陸してみると、3つの箱がある。
さて、どちらがお宝だろうか。開けてみよう。

# インデックス検索

最後にインデックス検索を体験してみよう。
今度のお宝は、小さな島ではなく、大きな火山島の洞窟にある。

洞窟は入り口が一つであるが、入っていると左右に道が分かれている。
分かれ道には宝箱が置いてある。分かれ道の先は、同じく分かれ道か、行き止まりである。
行き止まりには宝箱はない。洞窟の中の宝箱の数は、8191個である。

宝箱の中にはそれぞれ異なる6桁の数字が入っている。
右の道を進んだ先にある宝箱の数字はすべてそれより大きく、左はすべてそれより小さい。

`777777`がお宝である。それ以外は落とし穴である。
20回落とし穴に落ちると海賊は死ぬ。

```
> cd ..
> cd index_cave
> ls
right box.txt left
```

使用できるコマンドは、`cd`,`cat`である。さあ探してみよう。


# 挿入操作

さて、思ったよりインデックス検索は面倒くさい。
実際、理論上バイナリ検索より早くすることはできない。

それでも使われている理由は何だろうか。
新しくデータを挿入してみよう。





